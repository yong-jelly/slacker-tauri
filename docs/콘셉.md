# 미루미(MIRUMI): 슬랙 '나중에' 항목 기반 작업 관리 및 추적 시스템

## 📋 프로젝트 개요

### 프로젝트명
**미루미(MIRUMI)** - Slack의 '나중에(Save for later)' 기능을 중심으로 한 엔터프라이즈급 작업 관리 및 추적 플랫폼

### 한 줄 요약
슬랙에서 누적된 '나중에' 항목들을 의도적으로 꺼내서, 시간 추적과 함께 체계적으로 처리하고 완료 현황을 가시화하는 생산성 도구

---

## 🎯 프로젝트가 필요한 이유

### 1. 슬랙 '나중에' 기능의 한계

#### 현재의 문제점
- **누적의 무한 반복**: 급한 업무 중에 '나중에' 버튼을 누르고 쌓아두기 시작하면, 시간이 지날수록 항목들이 기하급수적으로 증가
- **가시성의 상실**: 저장된 항목들이 슬랙 인터페이스에서 마치 블랙홀처럼 사라져, 언제 어떻게 처리해야 할지 불명확
- **우선순위의 모호성**: 단순 목록 형태로만 표시되어 어떤 항목이 더 중요하고 긴급한지 판단 불가
- **진행 상황의 불투명성**: 각 항목을 처리하는 데 얼마나 시간이 걸렸는지, 지금 상태가 어떤지 추적 불가
- **작업 간섭의 비용**: 다른 긴급 업무가 들어왔을 때, 현재 진행 중인 '나중에' 항목의 맥락(지금까지 소비한 시간, 진행 상황 메모)이 손실됨

#### 결과
대부분의 업무자들이 '나중에' 항목을 개별적으로 관리하지 못하고, 결국 **기한 없는 미루기**의 악순환에 빠짐

### 2. 팀장급 사용자의 특수한 필요성

#### 다중 작업 환경의 복잡성
- 팀장급의 업무는 본질적으로 **병렬 다중 작업(Multitasking)** 특성을 가짐
  - 전략적 기획 중에 팀원 이슈 발생
  - 회의 중에 긴급 결재 요청
  - 프로젝트 진행 중에 고객 미팅 예약
  
#### 문맥 손실의 비용
- 한 가지 작업을 중단하고 다른 작업으로 전환할 때, 이전 작업의 **문맥(Context) 복원 비용**이 매우 높음
- 지금까지의 작업 시간, 진행 메모, 마지막 상태를 기억해야 함
- 이런 정보 손실이 반복되면 **심각한 생산성 저하** 유발

#### 관리의 필요성
- 자신이 어떤 작업에 얼마나 시간을 소비하고 있는지 가시적으로 파악 필요
- 팀 내에서 각자 얼마나 많은 '나중에' 항목을 안고 있는지 모니터링
- 병목 작업, 지연 작업을 빠르게 식별하고 대응

---

## ✨ 미루미의 핵심 가치 제안

### 1. **의도적인 작업 처리 (Intentional Work Processing)**

#### Play 버튼의 의미
- 단순한 타이머가 아닌, **작업 시작의 명확한 신호**
- "지금부터 이 항목을 처리하겠다"는 의도의 명시적 표현
- 슬랙의 수동 저장과 달리, 능동적이고 계획적인 작업 시작

#### 심리학적 효과
- **Commitment(약속)**: Play 버튼을 누르는 순간 자신과의 약속 체결
- **Focus(집중)**: 단일 작업에 집중하도록 심리적 강화
- **Accountability(책임감)**: 자신의 시간 사용에 대한 책임 강화

### 2. **시간 추적을 통한 가시성 (Time Visibility)**

#### 왜 시간 추적이 중요한가?

**개별 관점**
- 각 작업에 실제로 얼마나 시간이 필요한지 데이터 기반으로 파악
- 어떤 작업이 생각보다 오래 걸리는지 식별
- 자신의 작업 패턴과 생산성 이해

**팀 관점**
- 팀장이 팀원들의 작업 분배 상황을 객관적으로 파악
- 누가 과도한 '나중에' 항목을 안고 있는지 조기 감지
- 스트레스와 과부하 지표로 활용

**조직 관점**
- 프로젝트 리소스 할당의 근거 데이터
- 프로세스 개선의 기반 정보

### 3. **상황 전환(Context Switching) 최소화**

#### 일시정지 + 메모 기능의 역할

**현재 상황 저장**
- Play 중인 작업에서 일시정지 → 지금까지의 시간 자동 기록
- 사용자가 작성한 진행 상황 메모 저장
- "여기까지 했고, 다음은 저것을 해야 한다" 같은 브레드크럼 흔적

**복귀 시 완벽한 복원**
- 다음에 같은 항목의 Play를 누르면:
  - 이전까지의 누적 시간 표시
  - 이전 세션의 메모와 스냅샷
  - 마치 5분 전에 멈춘 것처럼 즉시 재개 가능

**문맥 손실 방지**
- "어디까지 했더라?" 같은 기억 부담 제거
- 뇌의 인지 자원을 작업 자체에 집중
- 멀티태스킹의 부작용 최소화

### 4. **슬랙 통합을 통한 자동화 (Slack Integration)**

#### 양방향 동기화
- **Pull**: Slack의 '나중에' 항목을 미루미로 자동 가져오기
  - 새로운 '나중에' 항목이 추가되면 미루미에 자동으로 반영
  - 사용자는 별도의 입력 작업 없이 통합된 큐 유지

- **Push**: 미루미에서의 완료/진행을 Slack으로 피드백 (선택사항)
  - "이 항목 완료했습니다" → Slack 알림
  - 팀 내 진행 상황 공유 가능

#### 단일 출입구 (Single Point of Entry)
- 여러 도구를 오가는 번거로움 제거
- 새로운 작업은 Slack에서 자연스럽게, 기존 항목 처리는 미루미에서

---

## 🏗️ 핵심 기능 및 설계 원리

### 1. 작업 라이프사이클 (Task Lifecycle)

```
[Slack] 
  ↓
'나중에' 항목 생성
  ↓ API 동기화
[미루미] 
  ↓
┌─────────────────────────────────┐
│  INBOX (처리 대기 중)            │
│  - 우선순위 미설정              │
│  - 시간 추적 안 됨              │
└─────────────────────────────────┘
  ↓ Play 버튼
┌─────────────────────────────────┐
│  IN_PROGRESS (처리 중)          │
│  - 시간 계속 흐름               │
│  - 진행 메모 기록 가능          │
└─────────────────────────────────┘
  ↓ Pause 또는 다른 작업 우선순위
┌─────────────────────────────────┐
│  PAUSED (일시정지)              │
│  - 누적 시간 저장               │
│  - 진행 메모와 상태 저장        │
└─────────────────────────────────┘
  ↓ Resume (같은 항목 Play)
┌─────────────────────────────────┐
│  IN_PROGRESS (재개)             │
│  - 이전 누적 시간부터 계속      │
│  - 메모와 상태 복원             │
└─────────────────────────────────┘
  ↓ Complete 또는 폐기
┌─────────────────────────────────┐
│  COMPLETED / ARCHIVED           │
│  - 최종 시간 기록               │
│  - 완료 일시 저장               │
│  - 분석 데이터로 활용           │
└─────────────────────────────────┘
```

### 2. Play 버튼의 역할

#### 단순 타이머가 아닌 이유
- **상태 전환의 신호**: "이제 진지하게 시작한다"의 의식적 표현
- **시간 관리의 투명성**: 모든 시간이 기록되고 가시화됨
- **집중력 강화**: UI가 계속 진행 중임을 상기시킴

#### 작업 중 상황 변화 대응
```
[Play 중]
  ↓ 긴급 업무 발생
┌──────────────────────┐
│ Pause                │
│ 누적 시간: 23m 15s   │
│ 메모: "API 연동 작업 중...
│        - DB 스키마 확인 완료
│        - 다음: 쿼리 최적화" │
└──────────────────────┘
  ↓ 긴급 업무 처리
  ↓ 긴급 업무 완료
  ↓ 기존 항목 Play 재개
┌──────────────────────┐
│ In Progress          │
│ 누적 시간: 23m 15s   │ ← 이전 값에서 계속
│ 메모: [위의 메모 표시]│
│ 다시 집중 시작       │
└──────────────────────┘
```

### 3. 메모(Context) 저장의 중요성

#### 왜 메모가 필수인가?
- **문맥 복원의 가장 빠른 방법**: "여기까지 했고, 다음은 저거"를 5초 만에 파악
- **학습 루프**: 같은 작업을 반복할 때, 이전의 실수나 발견사항 상기
- **팀 커뮤니케이션**: 다른 팀원이 이 작업을 인수인계받을 때 필요한 정보

#### 메모의 형태
- **자유 텍스트**: 사용자 자신의 말로 진행 상황 기록
- **체크리스트**: 주요 작업 항목들 체크
- **타임스탬프**: 각 메모가 작성된 시각 자동 기록

### 4. 일시정지(Pause)가 필요한 이유

#### 아니 그냥 정지(Stop)는 안 되나?
- **Stop**: 작업을 끝낸다 → 다시 시작하려면 '완료'처럼 느껴짐
- **Pause**: 일시적으로 멈춘다 → 곧 다시 할 것 같은 심리적 상태

#### 다중 작업 환경에서 Pause의 가치
- 우선순위 높은 작업이 들어오면 현재 작업을 "완료하지 않고" 일시정지
- 완료 압박감 없이 편하게 중단
- 돌아올 때도 자연스럽게 재개

---

## 💼 타겟 사용자 및 사용 시나리오

### 주 타겟: 팀장급 관리자

#### 왜 팀장인가?

**작업 특성**
1. **병렬 다중 작업**: 전략 수립 → 팀원 이슈 → 회의 → 다시 전략으로 자주 전환
2. **인터럽트가 많음**: 슬랙 메시지, 긴급 요청, 미팅 알림 등이 계속 들어옴
3. **장시간 프로젝트와 단시간 태스크 혼재**: 큰 계획과 작은 결정을 동시에 관리

**관리 필요성**
1. **자신의 시간 관리**: 각 업무에 실제로 몇 시간을 쓰고 있는지 파악
2. **팀 관찰**: 팀원들의 작업 부하 상황을 객관적 데이터로 모니터링
3. **병목 식별**: 어떤 작업이 자주 미루어지는지 패턴 파악

### 실제 사용 시나리오

#### 시나리오 1: 일반적인 업무 처리
```
09:00 - 아침 회의에서 3개의 액션 아이템 발생
        → Slack '나중에'로 저장
        
09:30 - 미루미 확인, 우선순위 정렬
        → "공급망 최적화 분석" 선택
        → Play 버튼 클릭
        
10:15 - 25분 경과, Slack 메시지 확인
        중요한 팀원 이슈 발생
        
10:16 - Pause 버튼 클릭
        메모: "데이터 수집 및 초안 완료 ✓
               다음: 비용 분석 시뮬레이션"
        
10:17 ~ 10:45 - 팀원 이슈 해결 (별도 작업)

10:46 - "공급망 최적화 분석" 다시 열기
        누적 시간: 25m 표시
        이전 메모 보면서 즉시 재개
        
12:00 - 총 78분 소비하여 완료 마크
```

#### 시나리오 2: 팀장의 주간 리뷰
```
금요일 오후 4시 - 팀 스탠드업 전에 미루미 대시보드 확인

[Inbox 현황]
- 미 처리: 12개 (지난주 15개)
- 이번주 완료: 3개

[각 팀원의 '나중에' 현황]
- 팀원A: 8개 (우려 수준) → 상담 필요
- 팀원B: 2개 (건강)
- 팀원C: 5개 (증가 추세) → 모니터링

[시간 분석]
- 이번주 "회의 및 보고" 항목에 총 4시간 소비
- 평균 작업 완료 시간: 42분
- "병목 작업": DB 마이그레이션 (처음 시작 후 4일 미처리)

→ 이 정보를 토대로 팀과 작업 분배 및 지원 논의
```

---

## 🛠️ 기술 스택 선택 이유

### Tauri (Desktop Application)
- **왜 Tauri인가?**
  - 가벼운 번들 사이즈: 개발자 배포/관리 용이
  - 네이티브 OS 통합: macOS, Windows, Linux 모두 지원
  - 오프라인 우선: 슬랙이 없어도 로컬에서 데이터 추적
  - Rust 백엔드: 성능과 보안

- **Electron과의 비교**
  - Electron: 무겁지만 풍부한 생태계
  - Tauri: 가벼우면서도 필요한 모든 기능 제공
  - 결정: Tauri (팀장들이 항상 켜놓고 쓸 애플리케이션이므로 경량성 중요)

### Bun (Runtime & Build)
- **왜 Bun인가?**
  - 번들링과 런타임 모두 제공
  - Node.js 호환성: 기존 npm 패키지 사용 가능
  - 개발 속도: 빠른 HMR과 빌드
  - TypeScript 원시 지원: 추가 트랜스파일링 불필요

- **백엔드**
  - Bun의 내장 서버 또는 Hono 같은 경량 프레임워크
  - Tauri에서 API 호출을 통해 로컬 DB 조작

### 데이터 저장소
- **로컬 DB**: SQLite 또는 PostgreSQL (개발용 로컬 인스턴스)
  - 오프라인 우선: 항상 접근 가능
  - 민감한 데이터 (Slack 토큰 등) 안전 저장

- **클라우드 (선택사항)**
  - 향후 팀 공유 기능 추가 시 필요
  - 초기에는 로컬 전용으로 시작

---

## 📊 핵심 데이터 모델 (개요)

### Task (작업)
```
- id: UUID
- slack_message_id: string (Slack에서의 원본 ID)
- title: string
- description: string
- url: string (Slack 메시지 링크)
- priority: enum (LOW, MEDIUM, HIGH)
- status: enum (INBOX, IN_PROGRESS, PAUSED, COMPLETED, ARCHIVED)
- total_time_spent: integer (분)
- created_at: timestamp
- completed_at: timestamp (nullable)
- last_paused_at: timestamp (nullable)
```

### Session (작업 세션)
```
- id: UUID
- task_id: UUID
- started_at: timestamp
- paused_at: timestamp (nullable)
- duration: integer (분)
- notes: text
```

### Task Note (진행 메모)
```
- id: UUID
- task_id: UUID
- content: text
- created_at: timestamp
- session_id: UUID (nullable, 특정 세션과 연관되면)
```

---

## 🚀 초기 개발 로드맵 (Phase 1)

### Phase 1: MVP (최소 실행 가능 제품)
1. **Slack API 통합**
   - '나중에' 항목 읽기 API 구현
   - 주기적 동기화 (매 1시간 또는 수동 새로고침)
   
2. **기본 UI**
   - Task 목록 표시
   - Play / Pause / Complete 버튼
   - 누적 시간 표시
   
3. **로컬 데이터 저장**
   - 각 Task의 상태 저장
   - 누적 시간 기록
   - 메모 저장

4. **기본 분석**
   - 완료된 작업 통계
   - 시간 사용 분석

### Phase 2: 팀 기능
- 팀 멤버 등록
- 팀 대시보드
- 팀원 작업 현황 조회

### Phase 3: 고급 기능
- 반복 작업 지원
- 예측 완료 시간
- 자동 우선순위 정렬
- Slack과 양방향 동기화

---

## 📌 핵심 가치 명제 (Value Proposition)

| 문제 | 미루미의 해결책 |
|------|-----------------|
| 슬랙 '나중에'는 쌓이기만 하고 처리 안 됨 | API 통합으로 명시적 처리 플로우 제공 |
| 어느 작업에 실제로 시간이 얼마나 드는지 모름 | 시간 추적으로 객관적 데이터 제공 |
| 업무 중단 후 재개 시 문맥 손실 | 메모 + 시간 기록으로 완벽한 문맥 복원 |
| 다중 업무 중 우선순위 관리 어려움 | 우선순위 정렬 + Play/Pause 시스템 |
| 팀원들의 업무 부하 파악 어려움 | 팀 대시보드로 가시성 확보 |

---

## 🎓 설계 철학

### 1. **불필요한 것을 빼기**
- 복잡한 예약 달력: 필요 없음 (Slack 메시지 기반)
- 팀 협업 에디팅: 초기에 필요 없음
- 과도한 자동화: 사용자의 의도적 행동 강조

### 2. **맥락 중심의 설계**
- UI의 모든 요소가 "지금 이 작업에서 내가 뭘 해야 하는가"를 빠르게 보여줌
- 이전 메모, 소비 시간, 현재 상태를 한눈에

### 3. **점진적 학습**
- 초기: 개인용 시간 추적 도구
- 발전: 팀 관찰 도구로 성장
- 최종: 조직의 생산성 인텔리전스 플랫폼

---

## 📝 다음 단계

1. **API 명세 작성** (Slack API 활용 방법, 미루미 백엔드 API)
2. **데이터 스키마 상세 설계** (ERD, 정규화)
3. **UI/UX 와이어프레임** (Tauri 앱 레이아웃)
4. **개발 시작** (Bun + Tauri 프로젝트 초기 설정)